---
description: The currentSeed getter can be used for access
---

# Accessing a Random Seed in a Smart Contract

The new `RandomAuRa contract` allows smart contracts to access a random, on-chain number generated within the protocol. It is generated by the validators themselves, using a RANDAO-like process \([https://github.com/randao/randao](https://github.com/randao/randao)\).

The public getter `currentSeed` can be used to access the network's random seed. Its value is only updated when the `revealSecret` function is called. This should occur at least once per collection round. The length in blocks of each collection round can be retrieved with the `collectRoundLength` public getter. There are two phases, a `commits phase` and a `reveals phase`. Since the revealing validator always knows the next random number before sending it, a DApp should prohibit business logic actions that depend on a random value during the `reveals phase`.

For example, with a betting application, bets should only be placed during the `commits phase`. For more information, see [RNG Implementation Explainer.](rng-implementation-explainer.md)

## Example code to retrieve a random seed

```javascript
pragma solidity 0.5.11;


interface IPOSDAORandom {
    function collectRoundLength() external view returns(uint256);
    function currentSeed() external view returns(uint256);
}

contract Example {
    IPOSDAORandom private _posdaoRandomContract; // address of RandomAuRa contract
    uint256 private _seed;
    uint256 private _seedLastBlock;
    uint256 private _updateInterval;

    constructor(IPOSDAORandom _randomContract) public {
        require(_randomContract != IPOSDAORandom(0));
        _posdaoRandomContract = _randomContract;
        _seed = _randomContract.currentSeed();
        _seedLastBlock = block.number;
        _updateInterval = _randomContract.collectRoundLength();
        require(_updateInterval != 0);
    }

    function useSeed() public {
        if (_wasSeedUpdated()) {
            // using updated _seed ...
        } else {
            // using _seed ...
        }
    }

    function _wasSeedUpdated() private returns(bool) {
        if (block.number - _seedLastBlock <= _updateInterval) {
            return false;
        }

        _updateInterval = _posdaoRandomContract.collectRoundLength();

        uint256 remoteSeed = _posdaoRandomContract.currentSeed();
        if (remoteSeed != _seed) {
            _seed = remoteSeed;
            _seedLastBlock = block.number;
            return true;
        }
        return false;
    }
}
```

